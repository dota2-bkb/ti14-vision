<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dota 2 Events Visualizer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        .header-section {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 30px;
        }

        h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            flex: 1;
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            flex: 0 0 350px;
        }

        .upload-section h3 {
            margin: 0 0 8px 0;
            font-size: 1.1em;
        }

        .upload-section p {
            margin: 0 0 12px 0;
            font-size: 0.9em;
            line-height: 1.3;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-size: 16px;
            border: none;
        }

        .file-input-wrapper:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .controls-section {
            display: flex;
            gap: 30px;
            margin-bottom: 30px;
            margin-top: 30px;
        }

        .game-selector {
            flex: 0 0 300px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            height: 1120px;
            overflow-y: auto;
        }

        .game-selector h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #FFD700;
        }

        .game-item {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 5px;
            transition: background 0.2s ease;
        }

        .game-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .game-item input[type="checkbox"] {
            margin-right: 10px;
            transform: scale(1.2);
        }

        .game-item label {
            cursor: pointer;
            flex: 1;
            font-size: 14px;
        }

        .side-section {
            margin-bottom: 25px;
        }

        .side-section h4 {
            margin: 0 0 10px 0;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 1.1em;
            font-weight: bold;
        }

        .side-section.radiant h4 {
            background: rgba(144, 238, 144, 0.2);
            color: #90EE90;
            border: 1px solid rgba(144, 238, 144, 0.3);
        }

        .side-section.dire h4 {
            background: rgba(255, 107, 107, 0.2);
            color: #FF6B6B;
            border: 1px solid rgba(255, 107, 107, 0.3);
        }

        .side-games {
            padding-left: 10px;
        }

        .side-controls {
            margin-bottom: 10px;
            display: flex;
            gap: 8px;
        }

        .side-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 6px 12px;
            margin: 0;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s ease;
            font-size: 12px;
        }

        .side-btn:hover {
            background: #2980b9;
        }

        .side-btn.danger {
            background: #e74c3c;
        }

        .side-btn.danger:hover {
            background: #c0392b;
        }

        .side-radiant {
            color: #90EE90;
        }

        .side-dire {
            color: #FF6B6B;
        }

        .visualization-section {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            position: relative;
        }
        .visualization-section h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #FFD700;
        }

        .visualization-controls {
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .slider-control {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .slider-control label {
            font-size: 14px;
            min-width: 200px;
        }

        .slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #FFD700;
            cursor: pointer;
            border: 2px solid #FFA500;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #FFD700;
            cursor: pointer;
            border: 2px solid #FFA500;
        }

        .toggle-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .toggle-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .toggle-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .toggle-btn.active {
            background: #27ae60;
        }

        .toggle-btn.active:hover {
            background: #229954;
        }

        .toggle-btn:not(.active):hover {
            background: #c0392b;
        }

        .map-container {
            position: relative;
            width: 100%;
            height: 0;
            padding-bottom: 100%; /* 1:1 aspect ratio - adjust based on your map image */
            background: #2c3e50;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #34495e;
        }

        .map-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('dota2_map.jpg') center/contain;
            background-repeat: no-repeat;
        }

        .event-marker {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid white;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 10;
        }

        .event-marker:hover {
            transform: scale(1.5);
            z-index: 20;
        }

        .event-marker.observer {
            background: #FFD700;
            border: 2px solid #FFA500;
            border-radius: 50%;
        }

        .event-marker.sentry {
            background: #4169E1;
            border: 2px solid #0000CD;
            border-radius: 2px;
        }

        .event-marker.smoke {
            background: #9932CC;
            border: 2px solid #8A2BE2;
            border-radius: 2px;
            transform: rotate(45deg);
        }

        .event-marker.smoke:hover {
            transform: rotate(45deg) scale(1.5);
        }

        .event-time {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            white-space: nowrap;
            pointer-events: none;
            z-index: 15;
            transform: translate(-50%, -100%);
            margin-top: -5px;
        }

        .path-arrow {
            position: absolute;
            pointer-events: none;
            z-index: 5;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .legend {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .legend-marker {
            width: 12px;
            height: 12px;
            margin-right: 8px;
        }

        .legend-marker.observer {
            background: #FFD700;
            border: 2px solid #FFA500;
            border-radius: 50%;
        }

        .legend-marker.sentry {
            background: #4169E1;
            border: 2px solid #0000CD;
            border-radius: 2px;
        }

        .legend-marker.smoke {
            background: #9932CC;
            border: 2px solid #8A2BE2;
            transform: rotate(45deg);
        }

        .stats-section {
            margin-top: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #FFD700;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .control-buttons {
            margin-bottom: 15px;
            text-align: center;
        }

        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .btn:hover {
            background: #2980b9;
        }

        .btn.danger {
            background: #e74c3c;
        }

        .btn.danger:hover {
            background: #c0392b;
        }

        .loading {
            text-align: center;
            padding: 20px;
            font-size: 18px;
        }

        .error {
            color: #ff6b6b;
            text-align: center;
            padding: 20px;
            background: rgba(255, 107, 107, 0.1);
            border-radius: 8px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-section">
            <h1>üéÆ Dota 2 Game Vision Visualizer - SPACE</h1>
            
            <div class="upload-section">
                <h3>Load Events Data</h3>
                <p>Select events_summary.csv file</p>
                <label class="file-input-wrapper">
                    üìÅ Choose CSV File
                    <input type="file" id="csvFile" accept=".csv" />
                </label>
            </div>
        </div>

        <div id="dataSection" style="display: none;">
            <div class="controls-section">
                <div class="game-selector">
                    <h3>üéØ Game Selection</h3>
                    <div id="gamesList"></div>
                </div>

                <div class="visualization-section">
                    <h3>üìç Events Visualization</h3>
                    <div class="visualization-controls">
                        <div class="slider-control">
                            <label for="wardLimitSlider">Max Observer Wards per Game: <span id="wardLimitValue">2</span></label>
                            <input type="range" id="wardLimitSlider" min="1" max="20" value="2" class="slider">
                        </div>
                        <div class="toggle-controls">
                            <button id="sentryToggle" class="btn toggle-btn" onclick="toggleSentryWards()">
                                üîµ Show Sentry Wards
                            </button>
                        </div>
                    </div>
                    <div class="map-container">
                        <div class="map-background" id="mapContainer">
                            <div class="legend">
                                <div class="legend-item">
                                    <div class="legend-marker observer"></div>
                                    <span>Observer Ward (Yellow Circle)</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-marker sentry"></div>
                                    <span>Sentry Ward (Blue Square)</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-marker smoke"></div>
                                    <span>Smoke (Purple Diamond)</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="stats-section" id="statsSection">
                <!-- Stats will be populated by JavaScript -->
            </div>
        </div>

        <div id="loadingSection" class="loading" style="display: none;">
            Loading data...
        </div>

        <div id="errorSection" class="error" style="display: none;">
            <!-- Error messages will appear here -->
        </div>
    </div>

    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script>
        let gamesData = [];
        let allEvents = [];
        let selectedGames = new Set();
        let maxObserverWards = 2;
        let showSentryWards = false;

        // File upload handler
        document.getElementById('csvFile').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (file) {
                loadCSVFile(file);
            }
        });

        // Ward limit slider handler
        document.getElementById('wardLimitSlider').addEventListener('input', function(event) {
            maxObserverWards = parseInt(event.target.value);
            document.getElementById('wardLimitValue').textContent = maxObserverWards;
            if (gamesData.length > 0) {
                updateVisualization();
                updateStats();
            }
        });

        function loadCSVFile(file) {
            showLoading(true);
            hideError();

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csv = e.target.result;
                    parseCSVData(csv);
                    showLoading(false);
                    document.getElementById('dataSection').style.display = 'block';
                } catch (error) {
                    showError('Error parsing CSV file: ' + error.message);
                    showLoading(false);
                }
            };
            reader.readAsText(file);
        }

        function convertPythonTuplesToJSON(str) {
            // Convert Python tuples to JSON arrays
            // This handles various tuple formats: (x, y), (-x, y), (x.y, z.w), etc.
            return str.replace(/\(([^)]+)\)/g, function(match, content) {
                // Split by comma and clean up each part
                const parts = content.split(',').map(part => part.trim());
                if (parts.length === 2) {
                    // Check if both parts are numbers (int or float, positive or negative)
                    const num1 = parseFloat(parts[0]);
                    const num2 = parseFloat(parts[1]);
                    if (!isNaN(num1) && !isNaN(num2)) {
                        return `[${num1}, ${num2}]`;
                    }
                }
                // If not a valid number tuple, return original
                return match;
            });
        }

        function parseCSVData(csv) {
            const lines = csv.trim().split('\n');
            const headers = lines[0].split(',');
            
            gamesData = [];
            allEvents = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i];
                if (!line.trim()) continue;

                // Parse CSV line carefully (handling quoted content)
                const parts = parseCSVLine(line);
                if (parts.length < 3) continue;

                const eventsStr = parts[0].replace(/^"|"$/g, ''); // Remove surrounding quotes
                const side = parts[1];
                const gameId = parts[2];

                try {
                    // Parse the events JSON string - need to handle Python tuples
                    let jsonStr = eventsStr.replace(/'/g, '"');
                    
                    // More comprehensive tuple replacement
                    jsonStr = convertPythonTuplesToJSON(jsonStr);
                    
                    console.log('Attempting to parse JSON for game', gameId);
                    console.log('JSON string sample:', jsonStr.substring(0, 300));
                    
                    const eventsData = JSON.parse(jsonStr);
                    
                    const gameInfo = {
                        gameId: gameId,
                        side: side,
                        events: eventsData
                    };

                    gamesData.push(gameInfo);

                    // Extract all events for visualization
                    Object.keys(eventsData).forEach(hero => {
                        eventsData[hero].forEach(event => {
                            allEvents.push({
                                ...event,
                                hero: hero,
                                gameId: gameId,
                                side: side
                            });
                        });
                    });
                } catch (e) {
                    console.error('Failed to parse events for game', gameId, ':', e);
                    console.error('Raw events string:', eventsStr.substring(0, 500) + '...');
                    
                    // Try to find the problematic part
                    const problemIndex = e.message.includes('position') ? eventsStr.indexOf('position_px') : -1;
                    if (problemIndex > -1) {
                        console.error('Problem area:', eventsStr.substring(Math.max(0, problemIndex - 50), problemIndex + 100));
                    }
                    
                    // Continue processing other games instead of stopping
                    continue;
                }
            }

            console.log(`Successfully parsed ${gamesData.length} games out of ${lines.length - 1} total games`);
            
            if (gamesData.length === 0) {
                showError('No games could be parsed from the CSV file. Please check the file format.');
                return;
            }
            
            populateGamesList();
            updateVisualization();
            updateStats();
        }

        function parseCSVLine(line) {
            const result = [];
            let current = '';
            let inQuotes = false;
            let i = 0;

            while (i < line.length) {
                const char = line[i];
                
                if (char === '"') {
                    if (inQuotes && line[i + 1] === '"') {
                        // Escaped quote
                        current += '"';
                        i += 2;
                        continue;
                    } else {
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    result.push(current);
                    current = '';
                    i++;
                    continue;
                } else {
                    current += char;
                }
                i++;
            }
            
            result.push(current);
            return result;
        }

        function populateGamesList() {
            const gamesList = document.getElementById('gamesList');
            gamesList.innerHTML = '';

            // Group games by side
            const gamesBySide = {
                radiant: [],
                dire: []
            };

            gamesData.forEach((game, index) => {
                gamesBySide[game.side].push({ ...game, originalIndex: index });
            });

            // Create sections for each side
            ['radiant', 'dire'].forEach(side => {
                if (gamesBySide[side].length === 0) return;

                // Create side section
                const sideSection = document.createElement('div');
                sideSection.className = `side-section ${side}`;

                const sideHeader = document.createElement('h4');
                sideHeader.textContent = `${side.charAt(0).toUpperCase() + side.slice(1)} (${gamesBySide[side].length} games)`;
                sideSection.appendChild(sideHeader);

                // Add side-specific control buttons
                const sideControls = document.createElement('div');
                sideControls.className = 'side-controls';

                const selectAllBtn = document.createElement('button');
                selectAllBtn.className = 'side-btn';
                selectAllBtn.textContent = 'Select All';
                selectAllBtn.onclick = () => selectAllSide(side);

                const deselectAllBtn = document.createElement('button');
                deselectAllBtn.className = 'side-btn danger';
                deselectAllBtn.textContent = 'Deselect All';
                deselectAllBtn.onclick = () => deselectAllSide(side);

                sideControls.appendChild(selectAllBtn);
                sideControls.appendChild(deselectAllBtn);
                sideSection.appendChild(sideControls);

                const sideGames = document.createElement('div');
                sideGames.className = 'side-games';

                gamesBySide[side].forEach((game, sideIndex) => {
                    const gameItem = document.createElement('div');
                    gameItem.className = 'game-item';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `game_${game.originalIndex}`;
                    // Only check the first 3 games overall by default
                    checkbox.checked = game.originalIndex < 3;
                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            selectedGames.add(game.gameId);
                        } else {
                            selectedGames.delete(game.gameId);
                        }
                        updateVisualization();
                        updateStats();
                    });

                    const label = document.createElement('label');
                    label.htmlFor = `game_${game.originalIndex}`;
                    label.innerHTML = `<strong>Game ${game.gameId}</strong>`;

                    gameItem.appendChild(checkbox);
                    gameItem.appendChild(label);
                    sideGames.appendChild(gameItem);

                    // Only add the first 3 games overall to selectedGames by default
                    if (game.originalIndex < 3) {
                        selectedGames.add(game.gameId);
                    }
                });

                sideSection.appendChild(sideGames);
                gamesList.appendChild(sideSection);
            });
        }


        function selectAllSide(side) {
            // Find all games of the specified side and select them
            gamesData.forEach(game => {
                if (game.side === side) {
                    selectedGames.add(game.gameId);
                }
            });
            
            // Update checkboxes for this side
            document.querySelectorAll('#gamesList input[type="checkbox"]').forEach(cb => {
                const gameIndex = parseInt(cb.id.replace('game_', ''));
                const game = gamesData[gameIndex];
                if (game && game.side === side) {
                    cb.checked = true;
                }
            });
            
            updateVisualization();
            updateStats();
        }

        function deselectAllSide(side) {
            // Find all games of the specified side and deselect them
            gamesData.forEach(game => {
                if (game.side === side) {
                    selectedGames.delete(game.gameId);
                }
            });
            
            // Update checkboxes for this side
            document.querySelectorAll('#gamesList input[type="checkbox"]').forEach(cb => {
                const gameIndex = parseInt(cb.id.replace('game_', ''));
                const game = gamesData[gameIndex];
                if (game && game.side === side) {
                    cb.checked = false;
                }
            });
            
            updateVisualization();
            updateStats();
        }

        function toggleSentryWards() {
            showSentryWards = !showSentryWards;
            const toggleBtn = document.getElementById('sentryToggle');
            
            if (showSentryWards) {
                toggleBtn.textContent = 'üîµ Hide Sentry Wards';
                toggleBtn.classList.add('active');
            } else {
                toggleBtn.textContent = 'üîµ Show Sentry Wards';
                toggleBtn.classList.remove('active');
            }
            
            if (gamesData.length > 0) {
                updateVisualization();
                updateStats();
            }
        }

        function updateVisualization() {
            const mapContainer = document.getElementById('mapContainer');
            
            // Remove existing markers, time labels, and arrows
            document.querySelectorAll('.event-marker').forEach(marker => marker.remove());
            document.querySelectorAll('.event-time').forEach(timeLabel => timeLabel.remove());
            document.querySelectorAll('.path-arrow').forEach(arrow => arrow.remove());

            // Filter events based on selected games and ward limits
            const filteredEvents = filterEventsByWardLimit(allEvents.filter(event => selectedGames.has(event.gameId)));

            // Group events by game and hero for path drawing
            const eventsByGameAndHero = {};
            filteredEvents.forEach(event => {
                const key = `${event.gameId}_${event.hero}`;
                if (!eventsByGameAndHero[key]) {
                    eventsByGameAndHero[key] = [];
                }
                eventsByGameAndHero[key].push(event);
            });

            // Sort events by time within each hero group
            Object.keys(eventsByGameAndHero).forEach(key => {
                eventsByGameAndHero[key].sort((a, b) => {
                    return parseTime(a.time) - parseTime(b.time);
                });
            });

            // Draw path arrows first (so they appear behind markers)
            Object.values(eventsByGameAndHero).forEach(heroEvents => {
                drawHeroPath(heroEvents, mapContainer);
            });

            // Count observer wards per game for labeling
            const observerWardCounts = {};
            const sortedFilteredEvents = [...filteredEvents].sort((a, b) => {
                if (a.gameId !== b.gameId) {
                    return a.gameId.localeCompare(b.gameId);
                }
                return parseTime(a.time) - parseTime(b.time);
            });

            // Deduplicate smoke events for visualization (same smoke affects multiple heroes)
            const seenSmokeEvents = new Set();
            const eventsToVisualize = sortedFilteredEvents.filter(event => {
                if (event.key_action === 'smoke') {
                    const smokeKey = `${event.gameId}_${event.time}_${event.position.left_percent}_${event.position.top_percent}`;
                    if (seenSmokeEvents.has(smokeKey)) {
                        return false; // Skip duplicate smoke event
                    }
                    seenSmokeEvents.add(smokeKey);
                }
                return true;
            });

            // Add markers and time labels for filtered events
            eventsToVisualize.forEach(event => {
                if (event.position && event.position.left_percent !== undefined && event.position.top_percent !== undefined) {
                    // Track observer ward count per game
                    if (event.key_action === 'placed_observer') {
                        if (!observerWardCounts[event.gameId]) {
                            observerWardCounts[event.gameId] = 0;
                        }
                        observerWardCounts[event.gameId]++;
                        event.observerWardNumber = observerWardCounts[event.gameId];
                    }
                    
                    const { marker, timeLabel } = createEventMarker(event);
                    mapContainer.appendChild(marker);
                    mapContainer.appendChild(timeLabel);
                }
            });

            // Update legend visibility
            updateLegendVisibility();
        }

        function updateLegendVisibility() {
            const sentryLegendItem = document.querySelector('.legend-item:nth-child(2)');
            if (sentryLegendItem) {
                sentryLegendItem.style.display = showSentryWards ? 'flex' : 'none';
            }
        }

        function createEventMarker(event) {
            const marker = document.createElement('div');
            marker.className = `event-marker ${event.key_action.replace('placed_', '')}`;
            
            // Position the marker
            const left = Math.max(0, Math.min(100, event.position.left_percent));
            const top = Math.max(0, Math.min(100, event.position.top_percent));
            
            marker.style.left = `${left}%`;
            marker.style.top = `${top}%`;

            // Create time label
            const timeLabel = document.createElement('div');
            timeLabel.className = 'event-time';
            
            // Add observer ward count for observer wards
            if (event.key_action === 'placed_observer' && event.observerWardNumber) {
                timeLabel.textContent = `${event.time} [${event.observerWardNumber}]`;
            } else {
                timeLabel.textContent = event.time;
            }
            
            timeLabel.style.left = `${left}%`;
            timeLabel.style.top = `${top}%`;

            // Add hover tooltip
            marker.addEventListener('mouseenter', function(e) {
                showTooltip(e, event);
            });

            marker.addEventListener('mouseleave', function() {
                hideTooltip();
            });

            // Return both marker and time label
            return { marker, timeLabel };
        }

        function showTooltip(e, event) {
            const tooltip = document.getElementById('tooltip');
            const actionText = event.key_action === 'smoke' ? 'Smoke of Deceit' : 
                              event.key_action === 'placed_observer' ? 'Observer Ward' : 'Sentry Ward';
            
            tooltip.innerHTML = `
                <strong>${event.hero}</strong><br>
                ${actionText}<br>
                Time: ${event.time}<br>
                Game: ${event.gameId} (${event.side})<br>
                Position: ${event.position.left_percent}%, ${event.position.top_percent}%
            `;
            
            tooltip.style.display = 'block';
            tooltip.style.left = e.pageX + 10 + 'px';
            tooltip.style.top = e.pageY - 10 + 'px';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        function filterEventsByWardLimit(events) {
            // Group events by game
            const eventsByGame = {};
            events.forEach(event => {
                const gameId = event.gameId;
                if (!eventsByGame[gameId]) {
                    eventsByGame[gameId] = [];
                }
                eventsByGame[gameId].push(event);
            });

            // Filter events by ward limit and time cutoff for each game
            const filteredEvents = [];
            Object.values(eventsByGame).forEach(gameEvents => {
                const gameId = gameEvents[0]?.gameId;
                console.log(`\nProcessing game ${gameId} with ${gameEvents.length} events`);
                // Sort by time first
                gameEvents.sort((a, b) => parseTime(a.time) - parseTime(b.time));
                
                // Find the time when the Nth observer ward is placed
                let observerWardCount = 0;
                let cutoffTime = null;
                
                for (let event of gameEvents) {
                    if (event.key_action === 'placed_observer') {
                        observerWardCount++;
                        if (observerWardCount === maxObserverWards) {
                            cutoffTime = parseTime(event.time);
                            break;
                        }
                    }
                }
                
                // If we don't have enough observer wards, include all events
                if (cutoffTime === null) {
                    console.log(`Game ${gameId}: No cutoff - including all events`);
                    gameEvents.forEach(event => {
                        if (event.key_action === 'placed_sentry') {
                            // Include sentry wards only if they're enabled
                            if (showSentryWards) {
                                filteredEvents.push(event);
                            }
                        } else {
                            // Include observer wards and smoke events
                            filteredEvents.push(event);
                        }
                    });
                } else {
                    console.log(`Game ${gameId}: Cutoff at ${cutoffTime} seconds`);
                    let includedEvents = 0;
                    let excludedEvents = 0;
                    gameEvents.forEach(event => {
                        const eventTime = parseTime(event.time);
                        if (eventTime <= cutoffTime) {
                            if (event.key_action === 'placed_sentry') {
                                // Include sentry wards only if they're enabled
                                if (showSentryWards) {
                                    filteredEvents.push(event);
                                    includedEvents++;
                                }
                            } else {
                                // Include observer wards and smoke events
                                filteredEvents.push(event);
                                includedEvents++;
                                // console.log(`Including event at ${event.key_action} ${event.time} (${eventTime}s <= ${cutoffTime}s)`);
                            }
                        } else {
                            excludedEvents++;
                            if (event.key_action === 'smoke') {
                                console.log(`Excluding smoke event at ${event.time} (${eventTime}s > ${cutoffTime}s)`);
                            }
                        }
                    });
                    console.log(`Game ${gameId}: Included ${includedEvents}, excluded ${excludedEvents} events`);
                }
            });

            return filteredEvents;
        }

        function parseTime(timeStr) {
            // Convert time string like "-00:42" or "05:30" to seconds
            const negative = timeStr.startsWith('-');
            const cleanTime = timeStr.replace('-', '');
            const parts = cleanTime.split(':');
            let seconds = 0;
            
            if (parts.length === 2) {
                seconds = parseInt(parts[0]) * 60 + parseInt(parts[1]);
            } else if (parts.length === 3) {
                seconds = parseInt(parts[0]) * 3600 + parseInt(parts[1]) * 60 + parseInt(parts[2]);
            }
            
            return negative ? -seconds : seconds;
        }

        function drawHeroPath(heroEvents, container) {
            if (heroEvents.length < 2) return;

            const containerRect = container.getBoundingClientRect();
            
            for (let i = 0; i < heroEvents.length - 1; i++) {
                const fromEvent = heroEvents[i];
                const toEvent = heroEvents[i + 1];
                
                if (!fromEvent.position || !toEvent.position) continue;
                
                const fromX = fromEvent.position.left_percent;
                const fromY = fromEvent.position.top_percent;
                const toX = toEvent.position.left_percent;
                const toY = toEvent.position.top_percent;
                
                // Skip if positions are too close or invalid
                if (Math.abs(fromX - toX) < 1 && Math.abs(fromY - toY) < 1) continue;
                if (fromX < 0 || fromX > 100 || toX < 0 || toX > 100) continue;
                if (fromY < 0 || fromY > 100 || toY < 0 || toY > 100) continue;
                
                drawArrow(container, fromX, fromY, toX, toY, getHeroColor(fromEvent.hero, fromEvent.gameId));
            }
        }

        function drawArrow(container, fromX, fromY, toX, toY, color) {
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.classList.add('path-arrow');
            svg.style.position = 'absolute';
            svg.style.top = '0';
            svg.style.left = '0';
            svg.style.width = '100%';
            svg.style.height = '100%';
            svg.style.pointerEvents = 'none';
            
            // Create arrow line
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.setAttribute('x1', `${fromX}%`);
            line.setAttribute('y1', `${fromY}%`);
            line.setAttribute('x2', `${toX}%`);
            line.setAttribute('y2', `${toY}%`);
            line.setAttribute('stroke', color);
            line.setAttribute('stroke-width', '2');
            line.setAttribute('opacity', '0.7');
            
            // Create arrowhead
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            const arrowId = `arrow-${Math.random().toString(36).substr(2, 9)}`;
            
            marker.setAttribute('id', arrowId);
            marker.setAttribute('markerWidth', '10');
            marker.setAttribute('markerHeight', '10');
            marker.setAttribute('refX', '8');
            marker.setAttribute('refY', '3');
            marker.setAttribute('orient', 'auto');
            marker.setAttribute('markerUnits', 'strokeWidth');
            
            const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            polygon.setAttribute('points', '0,0 0,6 9,3');
            polygon.setAttribute('fill', color);
            polygon.setAttribute('opacity', '0.7');
            
            marker.appendChild(polygon);
            defs.appendChild(marker);
            svg.appendChild(defs);
            
            line.setAttribute('marker-end', `url(#${arrowId})`);
            svg.appendChild(line);
            
            container.appendChild(svg);
        }

        function getHeroColor(heroName, gameId) {
            // Generate consistent color for each hero-game combination
            const colors = [
                '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7',
                '#DDA0DD', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9',
                '#F8C471', '#82E0AA', '#F1948A', '#85C1E9', '#D7BDE2'
            ];
            
            const hash = (heroName + gameId).split('').reduce((a, b) => {
                a = ((a << 5) - a) + b.charCodeAt(0);
                return a & a;
            }, 0);
            
            return colors[Math.abs(hash) % colors.length];
        }

        function updateStats() {
            // Get the same filtered events that are actually shown on the canvas
            const selectedEvents = allEvents.filter(event => selectedGames.has(event.gameId));
            const filteredEvents = filterEventsByWardLimit(selectedEvents);
            
            // Deduplicate smoke events by game and time (same smoke affects multiple heroes)
            const uniqueSmokeEvents = new Set();
            const smokeEvents = filteredEvents.filter(e => e.key_action === 'smoke');
            smokeEvents.forEach(event => {
                const smokeKey = `${event.gameId}_${event.time}`;
                uniqueSmokeEvents.add(smokeKey);
            });
            
            // Debug: let's see what's being counted
            console.log('Stats - Total filtered events:', filteredEvents.length);
            console.log('Stats - Raw smoke events:', smokeEvents.length);
            console.log('Stats - Unique smoke events:', uniqueSmokeEvents.size);
            console.log('Stats - Observer wards:', filteredEvents.filter(e => e.key_action === 'placed_observer').length);
            
            const stats = {
                totalEvents: filteredEvents.length - smokeEvents.length + uniqueSmokeEvents.size, // Adjust total for deduplication
                observerWards: filteredEvents.filter(e => e.key_action === 'placed_observer').length,
                sentryWards: filteredEvents.filter(e => e.key_action === 'placed_sentry').length,
                smokeEvents: uniqueSmokeEvents.size,
                selectedGames: selectedGames.size,
                totalGames: gamesData.length
            };

            const statsSection = document.getElementById('statsSection');
            statsSection.innerHTML = `
                <div class="stat-card">
                    <div class="stat-number">${stats.selectedGames}/${stats.totalGames}</div>
                    <div class="stat-label">Games Selected</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.totalEvents}</div>
                    <div class="stat-label">Total Events</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.observerWards}</div>
                    <div class="stat-label">Observer Wards</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.sentryWards}</div>
                    <div class="stat-label">Sentry Wards</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number">${stats.smokeEvents}</div>
                    <div class="stat-label">Smoke Events</div>
                </div>
            `;
        }

        function showLoading(show) {
            document.getElementById('loadingSection').style.display = show ? 'block' : 'none';
        }

        function showError(message) {
            const errorSection = document.getElementById('errorSection');
            errorSection.textContent = message;
            errorSection.style.display = 'block';
        }

        function hideError() {
            document.getElementById('errorSection').style.display = 'none';
        }

        // Initialize tooltip positioning
        document.addEventListener('mousemove', function(e) {
            const tooltip = document.getElementById('tooltip');
            if (tooltip.style.display === 'block') {
                tooltip.style.left = e.pageX + 10 + 'px';
                tooltip.style.top = e.pageY - 10 + 'px';
            }
        });
    </script>
</body>
</html>
